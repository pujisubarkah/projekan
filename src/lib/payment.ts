import { Xendit } from 'xendit-node';
import { db } from './db';
import { payments, projects, users } from './schema';
import { eq } from 'drizzle-orm';

const xendit = new Xendit({
  secretKey: process.env.XENDIT_SECRET_KEY!,
});

// Access QRIS through xendit instance with type assertion
const qris = (xendit as any).QRCode;

export interface CreatePaymentRequest {
  projectId: number;
  amount: number;
  description?: string;
}

export interface PaymentResponse {
  id: string;
  qrString: string;
  amount: number;
  expiresAt: string;
  status: string;
}

export class PaymentService {
  /**
   * Create QRIS payment for a project
   */
  static async createQRISPayment(request: CreatePaymentRequest): Promise<PaymentResponse> {
    try {
      // Get project and client info
      const project = await db
        .select({
          id: projects.id,
          title: projects.title,
          clientId: projects.clientId,
          client: {
            id: users.id,
            name: users.name,
            email: users.email,
          },
        })
        .from(projects)
        .leftJoin(users, eq(projects.clientId, users.id))
        .where(eq(projects.id, request.projectId))
        .limit(1);

      if (!project.length) {
        throw new Error('Project not found');
      }

      const projectData = project[0];

      // Create payment record in database
      const paymentRecord = await db.insert(payments).values({
        projectId: request.projectId,
        payerId: projectData.clientId,
        amount: request.amount,
        currency: 'IDR',
        provider: 'xendit',
        status: 'initiated',
      }).returning();

      const paymentId = paymentRecord[0].id;

      // Create QRIS payment with Xendit
      const qrPayment = await qris.createPayment({
        externalID: `projekan-payment-${paymentId}`,
        type: 'DYNAMIC',
        callbackURL: `${process.env.BASE_URL || 'http://localhost:5173'}/api/payments/webhook`,
        amount: request.amount,
        qrString: '', // Will be generated by Xendit
      });

      // Update payment record with provider reference
      await db
        .update(payments)
        .set({
          providerReference: qrPayment.external_id,
          status: 'initiated',
        })
        .where(eq(payments.id, paymentId));

      return {
        id: qrPayment.external_id,
        qrString: qrPayment.qr_string,
        amount: request.amount,
        expiresAt: new Date(Date.now() + 15 * 60 * 1000).toISOString(), // 15 minutes expiry
        status: 'pending',
      };
    } catch (error) {
      console.error('Error creating QRIS payment:', error);
      throw new Error('Failed to create payment');
    }
  }

  /**
   * Handle payment webhook from Xendit
   */
  static async handleWebhook(webhookData: any) {
    try {
      const { external_id, status, qr_code } = webhookData;

      // Extract payment ID from external_id
      const paymentId = parseInt(external_id.replace('projekan-payment-', ''));

      // Update payment status
      let paymentStatus: string;
      switch (status) {
        case 'COMPLETED':
          paymentStatus = 'paid';
          break;
        case 'FAILED':
          paymentStatus = 'failed';
          break;
        case 'EXPIRED':
          paymentStatus = 'cancelled';
          break;
        default:
          paymentStatus = 'initiated';
      }

      await db
        .update(payments)
        .set({
          status: paymentStatus as 'initiated' | 'paid' | 'failed' | 'refunded' | 'cancelled',
          updatedAt: new Date(),
        })
        .where(eq(payments.id, paymentId));

      // If payment completed, update project status
      if (paymentStatus === 'paid') {
        const payment = await db
          .select({ projectId: payments.projectId })
          .from(payments)
          .where(eq(payments.id, paymentId))
          .limit(1);

        if (payment.length > 0) {
          await db
            .update(projects)
            .set({
              status: 'in_progress',
              updatedAt: new Date(),
            })
            .where(eq(projects.id, payment[0].projectId));
        }
      }

      return { success: true };
    } catch (error) {
      console.error('Error handling payment webhook:', error);
      throw new Error('Failed to process webhook');
    }
  }

  /**
   * Get payment status
   */
  static async getPaymentStatus(paymentId: string) {
    try {
      const payment = await db
        .select()
        .from(payments)
        .where(eq(payments.providerReference, paymentId))
        .limit(1);

      if (!payment.length) {
        throw new Error('Payment not found');
      }

      return {
        id: payment[0].id,
        status: payment[0].status,
        amount: payment[0].amount,
        createdAt: payment[0].createdAt,
        updatedAt: payment[0].updatedAt,
      };
    } catch (error) {
      console.error('Error getting payment status:', error);
      throw new Error('Failed to get payment status');
    }
  }
}